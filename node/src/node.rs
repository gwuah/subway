use std::sync::Arc;
use tokio::net::UdpSocket;

use crate::errors::SubwayError;
use crate::ipv4::Header;
use crate::{config::Config, routing::Router};
use crate::{MAX_FRAME_SIZE, SUBWAY_PACKET_MARK};
use tokio::sync::broadcast;

use tokio_tun::{Tun, TunBuilder};

use std::os::unix::io::AsRawFd;

#[allow(dead_code)]
#[derive(Clone)]
pub struct Node {
    cfg: Config<'static>,
    socket: Arc<UdpSocket>,
    router: Router,
    tun: Arc<Tun>,
    cancel: broadcast::Sender<()>,
}

impl Drop for Node {
    fn drop(&mut self) {
        match self.router.detach_route_table() {
            Ok(_) => println!("routing table detached successfully"),
            Err(e) => println!("detach RT failed. requires manual cleanup. err={}", e,),
        }
    }
}

impl Node {
    pub async fn new(
        cfg: Config<'static>,
        router: Router,
        cancel: broadcast::Sender<()>,
    ) -> Result<Node, SubwayError> {
        // Initialize tun interface
        let tun = Arc::new(
            TunBuilder::new()
                .name(cfg.interface_name)
                .tap(false)
                .packet_info(true)
                .up()
                .try_build()
                .expect("failed to create tun interface"),
        );

        // assign a network to the tun inferface
        router.set_network(cfg.interface_name, cfg.network)?;

        // udp socket to transport packets to exit node
        let socket = Arc::new(
            UdpSocket::bind(cfg.tunnel_entry)
                .await
                .map_err(SubwayError::BindUdp)?,
        );

        // assign a special firewall mark to packets generated by our udp socket.
        // packets using this firewall will be routed using the default table.
        // every other packet without the mark will be directed to the tun device for tunneling.
        let result = unsafe {
            libc::setsockopt(
                socket.as_raw_fd(),
                libc::SOL_SOCKET,
                libc::SO_MARK,
                &SUBWAY_PACKET_MARK as *const u32 as *const libc::c_void,
                std::mem::size_of_val(&SUBWAY_PACKET_MARK) as _,
            )
        };
        if result == -1 {
            panic!("failed to set subway fwmark on socket")
        }

        return Ok(Node {
            cfg,
            tun,
            socket,
            router,
            cancel,
        });
    }

    pub async fn read_interface_write_tunnel(&self) -> Result<(), SubwayError> {
        let mut chan = self.cancel.subscribe();
        let mut packet = vec![0; MAX_FRAME_SIZE];
        loop {
            // read packets from interface attached to machine
            let res = tokio::select! {
                _ = chan.recv() => break,
                res = self.tun.recv(&mut packet[..]) => res,
            };

            let size = res.map_err(SubwayError::IOError)?;

            if size < 4 {
                continue;
            }

            // first 2 bytes = tun flags
            // second 2 bytes = protocol information
            // the real packet starts at index 4

            let (header, _) = Header::decode(&packet[4..size]).map_err(SubwayError::IOError)?;

            // handle only ipv4 packets for now
            if header.version != 4 {
                continue;
            }

            let addr = (header.src_addr, header.dst_addr);
            println!("tunneling connection from {} -> {}", addr);

            // write packet into tunnel
            let res = tokio::select! {
                _ = chan.recv() => break,
                res = self.socket.send_to(&packet[..size], self.cfg.tunnel_exit) => res,
            };
            let len = res.map_err(SubwayError::IOError)?;
            println!("wrote {} bytes to {}\n", len, self.cfg.tunnel_exit)
        }

        Ok(())
    }

    pub async fn read_tunnel_write_interface(&self) -> Result<(), SubwayError> {
        Ok(())
    }
}
